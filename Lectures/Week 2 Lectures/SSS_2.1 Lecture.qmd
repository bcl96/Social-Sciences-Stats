---
title: "Social Sciences Intro to Statistics"
subtitle: "Week 2.1 Basics of R"
format: pdf
editor: source
---
Week 2: Learning goal - Apply basic Dplyr functions in R and produce graphs of continuous and categorical variables.

 
```{r, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", highlight = TRUE, warning = FALSE, message = FALSE)
  #comment = "#>" makes it so results from a code chunk start with "#>"; default is "##"
```

# Introduction
Lecture overview:

- Practice dplyr functions
- Pipes %>%

### Libraries we will use today

"Load" the package we will use today (output omitted)

- __you must run this code chunk__
```{r, message=FALSE}
library(tidyverse)
```

# Pipes

### What are "pipes", %>%

__Pipes__ are a means of performing multiple steps in a single line of code. This helps us combine multiple operations together in a way that is concise. Pipes becomes very useful when we have many different operations in order to focus on new areas of the data. 

- When writing code, the pipe symbol is `%>%`
- The pipe operator `%>%` is created by the **magrittr** package, which is not part of base R
- However, the magrittr package is automatically loaded when you load the tidyverse package

```{r, eval = FALSE}
?magrittr::`%>%`
```

### What are "pipes", %>%

pipe syntax: `LHS %>% RHS`
  
- `LHS` (refers to "left hand side" of the pipe) is an object or function 
- `RHS` (refers to "right hand side" of the pipe) is a function

How pipes work:

- Object created by `LHS` becomes the first argument of the function (`RHS`) to the right of the `%>%` pipe symbol 
- Basic code flow: `object %>% function1 %>% function2 %>% function3`    
- Output of `some_function1` becomes the input (the first argument) of the function `some_function2` to the right of the `%>%` pipe symbol 

Example of using pipes to calculate mean value of atomic vector
```{r}
1:10 # an atomic vector
mean(1:10) # calculate mean without pipes
1:10 %>% mean() # calculate mean with pipes
```

- no pipe: (1) write function; (2) data object `1:10` is 1st argument of `mean()`
- pipe: (1) write data object; (2) "pipe" (verb) object as 1st argument of `mean()` 


```{r}
rm(list = ls()) # remove all objects in current environment

getwd()
netflix_data <- read_csv("https://raw.githubusercontent.com/bcl96/Social-Sciences-Stats/main/data/netflix_data/Netflix%20Movies%20Dataset%20All.csv")
```

### What are "pipes", %>%

\medskip

Intuitive mnemonic device for understanding pipes

- whenever you see a pipe `%>%` think of the words "__and then...__"

Example: isolate all the dramas [output omitted]

- in words: start with object `netflix_data` __and then__ filter productions under the main genre of drama
```{r, results="hide"}
netflix_data %>% filter(MAIN_GENRE == "drama")
```
    
below code in words:

- start with `netflix_data` __and then__ select a few vars __and then__ filter __and then__ sort  __and then__ investigate structure of object

```{r}
netflix_data %>% select(TITLE, MAIN_GENRE, RELEASE_YEAR, SCORE) %>% 
  filter(MAIN_GENRE == "drama", RELEASE_YEAR == "2017") %>% 
  arrange(desc(SCORE)) %>% str()
```

### More intuition on the pipe operator, `%>%`

Example: apply "structure" function `str()` to `netflix_data` with and without pipes
```{r, results="hide"}
str(netflix_data) # without pipe
netflix_data %>% str() # with pipe
```

I use the `str()` when I add new `%>%`; shows what kind of object being piped in

- task: select a few vars from `netflix_data`; isolate dramas in 2017; sort descending by score (output omitted)

```{r, eval = FALSE}

netflix_data %>% select(TITLE, MAIN_GENRE, RELEASE_YEAR, SCORE) %>% str()

netflix_data %>% select(TITLE, MAIN_GENRE, RELEASE_YEAR, SCORE) %>% 
  filter(MAIN_GENRE == "drama", RELEASE_YEAR == "2017") %>% str()

netflix_data %>% select(TITLE, MAIN_GENRE, RELEASE_YEAR, SCORE) %>% 
  filter(MAIN_GENRE == "drama", RELEASE_YEAR == "2017") %>% 
  arrange(desc(SCORE)) %>% str()
```


### Compare data tasks, with and without pipes

Task: Using object `netflix_data` print data for "drama" productions (`MAIN_GENRE == "drama"`)
```{r, results='hide'}
# without pipes
filter(netflix_data, MAIN_GENRE == "drama")

# with pipes
netflix_data %>% filter(MAIN_GENRE == "drama")
```

Comparing the two approaches:

- "without pipes", object `netflix_data` is the first argument `filter()` function
- In "pipes" approach, you don't specify object `wwlist` as first argument in `filter()`
    - Why? Because `%>%` "pipes" the object to the left of the `%>%` operator into the function to the right of the `%>%` operator
    


### Compare data tasks, with and without pipes

__Task__: Using object `netflix_data`, print data for "drama" productions for selected variables 
```{r, results='hide'}
#Without pipes
select(filter(netflix_data, MAIN_GENRE == "drama"), TITLE, RELEASE_YEAR, SCORE)
#With pipes
netflix_data %>% filter(MAIN_GENRE == "drama") %>% select(TITLE, RELEASE_YEAR, SCORE)
```



Comparing the two approaches:

- In the "without pipes" approach, code is written "inside out"
    - The first step in the task -- identifying the object -- is the innermost part of code
    - The last step in task -- selecting variables to print -- is the outermost part of code
- In "pipes" approach the left-to-right order of code matches how we think about the task
    - First, we start with an object __*and then*__ (`%>%`) we use `filter()` to isolate first-gen students __*and then*__ (`%>%`) we select which  variables to print

\medskip

`str()` helpful to understand object piped in from one function to another
```{r, results="hide"}
#object that was "piped" into `select()` from `filter()`
netflix_data %>% filter(MAIN_GENRE == "drama") %>% str()

#object that was created after `select()` function
netflix_data %>% filter(MAIN_GENRE == "drama") %>% select(TITLE, RELEASE_YEAR, SCORE) %>% str()
```

### Aside: `count()` function

\medskip `count()` function from `dplyr` package counts the number of obs by group
```{r, eval=FALSE, echo=FALSE}
?count
```

__Syntax__ [see help file for full syntax]

- `count(x,...)`

__Arguments__ [see help file for full arguments]

- `x`: an object, often a data frame
- `...`: variables to group by

Examples of using `count()`

- Without vars in `...` argument, counts number of obs in object
```{r, results="hide"}
count(netflix_data)
netflix_data %>% count()
netflix_data %>% count() %>% str()
```
- With vars in `...` argument, counts number of obs per variable value
    - This is the best way to create frequency table, better than `table()`
    - note: by default, `count()` always shows `NAs` [this is good!]
```{r, results="hide"}
count(netflix_data, SCORE)
netflix_data %>% count(SCORE)
netflix_data %>% count(SCORE) %>% str()
```

### pipe operators and new lines

\medskip Often want to insert line breaks to make long line of code more readable

- When inserting line breaks, __pipe operator `%>%` should be the last thing before a line break, not the first thing after a line break__

__This works__
```{r, results="hide"}
netflix_data %>% filter(MAIN_GENRE == "drama") %>% 
  select(TITLE, MAIN_GENRE, RELEASE_YEAR, SCORE) %>%
  count(SCORE)
```
__This works too__
```{r, results="hide"}
netflix_data %>% filter(MAIN_GENRE == "drama",
                  RELEASE_YEAR != "2017") %>% 
  select(TITLE, MAIN_GENRE, RELEASE_YEAR, SCORE) %>%
  count(SCORE)
```

__This doesn't work__
```{r, eval=FALSE}
netflix_data %>% filter(MAIN_GENRE == "drama") 
  %>% select(TITLE, MAIN_GENRE, RELEASE_YEAR, SCORE) 
  %>% count(SCORE)
```

### The power of pipes

You might be thinking, "what's the big deal?"

__TasK__:

- in one line of code, modify `netflix_data` and create bar chart that counts number of productions  by genre, separately for production outside of U.S. vs. inside of U.S.
```{r, eval=FALSE}
netflix_data %>%
  mutate( # create out-of-U.S. indicator
    out_us = as_factor(if_else(MAIN_PRODUCTION != "US", "outside-of-us", "inside-of-us"))
  ) %>%
  group_by(out_us) %>% # group_by "outside-of-us" vs. "inside-of-us"
  count(MAIN_GENRE) %>%  # count of number of productions by genre
  ggplot(aes(x=MAIN_GENRE, y=n)) +  # plot
  ylab("number of productions") + xlab("genre") +
  geom_col() +  coord_flip() + facet_wrap(~ out_us)
```

### The power of pipes

__TasK__:

- in one line of code, modify `netflix_data` and create bar chart of median income (in zip-code) of prospects purchased by race/ethnicity, separately for in-state vs. out-of-state
```{r, eval=FALSE}

netflix_data %>%
  mutate(out_us = as_factor(if_else(MAIN_PRODUCTION != "US", "outside-of-us", "inside-of-us"))) %>%
  ggplot(aes(x = MAIN_GENRE, y = SCORE * NUMBER_OF_VOTES, fill = out_us)) +
  geom_bar(stat = "identity", position = "dodge") +
  ylab("Total Votes") + xlab("Genre") +
  coord_flip() + facet_wrap(~ out_us)
```

### The power of pipes

Example R script from Ben Skinner, which creates analysis data for [Skinner (2018)](https://link.springer.com/article/10.1007%2Fs11162-018-9507-1)

- [Link to R script](https://github.com/btskinner/colchoice_rep/blob/master/scripts/makedata.r)

\medskip

Other relevant links

- [Link to Github repository for Skinner (2018)](https://github.com/btskinner/colchoice_rep)
- [Link to published paper](https://link.springer.com/article/10.1007%2Fs11162-018-9507-1)
- [Link to Skinner's Github page](https://github.com/btskinner)
    - A lot of cool stuff here
- [Link to Skinner's personal website](https://www.btskinner.io/)
    - A lot of cool stuff here

### Which objects and functions are pipeable

Which objects and functions are "pipeable" (i.e., work with pipes)

- function is pipeable if it takes a data object as first argument and returns an object of same type
-	In general, doesnâ€™t seem to be any limit on which kinds of objects are pipeable (could be atomic vector, list, data frame)

```{r, result = "hide"}
# applying pipes to atomic vectors
1:10 %>% mean
1:10 %>% mean %>% str()
```

But some pipeable functions restrict which kinds of data objects they accept

-	In particular, the `dplyr` functions (e.g., `filter`, `arrange`, etc.) expect the first argument to be a data frame. 
- `dpylr` functions wonâ€™t even accept a list as first argument, even though data frames are a particular class of list

```{r, eval = FALSE}
netflix_data %>% filter(MAIN_GENRE == "drama") %>% str()

as.data.frame(netflix_data)  %>% str()
as.data.frame(netflix_data) %>% filter(MAIN_GENRE == "drama") %>% str()

as.list(netflix_data)  %>% str()
```
