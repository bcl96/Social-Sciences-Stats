---
title: "Social Sciences Intro to Statistics"
subtitle: "Week 1.2 Basics of R"
format: pdf
editor: source
---
Week 1: Learning goal - Understand what and how to access R and R studio.

 
```{r, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", highlight = TRUE, warning = FALSE, message = FALSE)
  #comment = "#>" makes it so results from a code chunk start with "#>"; default is "##"
```

# Introduction

### Libraries we will use today

"Load" the package we will use today (output omitted)

- __you must run this code chunk__
```{r, message=FALSE}
library(tidyverse)
```
If package not yet installed, then must install before you load. Install in "console" rather than .Rmd file

- Generic syntax: `install.packages("package_name")`
- Install "tidyverse": `install.packages("tidyverse")`

Note: when we load package, name of package is not in quotes; but when we install package, name of package is in quotes:

- `install.packages("tidyverse")`
- `library(tidyverse)`

### tidyverse
The package we just downloaded, tidyverse,  is a programming package in R that helps us transform data. This package is important for data mutation and visualization.

# Investigating data patterns

### Introduction to the `dplyr` library

`dplyr`, a package within the `tidyverse` suite of packages, provide tools for manipulating data frames

- Wickham describes functions within `dplyr` as a set of "verbs" that fall in the broader categories of __subsetting__, __sorting__, and __transforming__

-select() extracts columns and returns a tibble.

-arrange() changes the ordering of the rows.

-filter() picks cases based on their values.

-mutate() adds new variables that are functions of existing variables.

-rename() easily changes the name of a column(s).

-pull() extracts a single column as a vector.

Today | Upcoming weeks
------------- | -------------
__Subsetting data__ | __Transforming data__
- `select()` variables  |  - `summarize()` calculates across rows
- `filter()` observations | - `group_by()` to calculate across rows within groups
- `mutate()` creates new variables |
- `pull()` variables 
__Sorting data__ | 
- `arrange()` | 
 __Transforming data__
- `rename`() variables |

All `dplyr` verbs (i.e., functions) work as follows

1. first argument is a data frame
1. subsequent arguments describe what to do with variables and observations in data frame
    - refer to variable names without quotes
1. result of the function is a new data frame


## Data for lecture sections on select(), arrange(), filter(), mutate(), rename(), and pull() functions

**Lecture overview**

- Introduction to Netflix data on IMDb score and votes
- Brief review of statistics (selected concepts)


## Libraries we will use

```{r}
#install.packages('tidyverse') # if you haven't installed already
#install.packages('labelled') # if you haven't installed already

library(tidyverse) # load tidyverse package
library(labelled) # load labelled package package
```

# Netflix Data

The [Netflix Data](https://data.world/gonzandrobles/netflix-movies-and-series) is a dataset created on *Data World* that compiled the best shows and movies on Netflix (as of May 2022).

- We will use data from the *Netflix Data* in lecture and potentially for some assignments
- Relevant links
  - [Data documentation](https://data.world/gonzandrobles/netflix-movies-and-series)
  - [Data download](https://github.com/bcl96/Social-Sciences-Stats/tree/main/data/netflix_data)


In the following sub-sections, we "load" the data, create modified datasets, investigate the data, and run some basic descriptive statistics

- **Your are not responsible for knowing the below code**
  - You will only be responsible for knowing code that we explicitly teach you during the quarter
- But try to follow the general logic of what the code is doing
- And try running the below "code chunks" on your own computer


## Data for lecture sections on pipes and mutate() function

### Load .csv data frame `netflix_data`


```{r}
#load netflix data
netflix_data <- read_csv("https://raw.githubusercontent.com/bcl96/Social-Sciences-Stats/main/data/netflix_data/Netflix%20Movies%20Dataset%20All.csv")

#print(netflix_data)
```

Object `netflix_data`

- Collection of all movies that have at least an IMDb score of 6.9 and at least 10,000 votes

Observations on `netflix_data`

- each observation represents a movie or tv series
```{r}
typeof(netflix_data)
class(netflix_data)
dim(netflix_data)
```

Variables on `netflix_data`

- some vars provide details about the movie or tv show
  - e.g., `TITLE`, `MAIN_GENRE`, `MAIN_PRODUCTION`
- some vars provide data about the IMDb votes and scores
  - e.g., `SCORE`, `NUMBER_OF_VOTES`
- some vars provide data about year the media was released
  - e.g., `RELEASE_YEAR` is year the movie or tv show was first released
```{r, results="hide"}
names(netflix_data)
str(netflix_data)
glimpse(netflix_data) # tidyverse function, similar to str()
```


Variable `MAIN_PRODUCTION` identifies where the movie or film was produced

Imagine we want to isolate all the U.S. productions

1. Investigate variable type/structure. 

- A dichotomous var, but stored as character in `netflix_data`. So must use quotes (`''` or `""`) to filter/subset based on values of `MAIN_PRODUCTION`
```{r}
str(netflix_data$MAIN_PRODUCTION)
```

2. Create frequency table to identify possible values of `MAIN_PRODUCTION`
```{r}
table(netflix_data$MAIN_PRODUCTION, useNA = "always")
```
3. Isolate all the US production (output omitted)
```{r results="hide"}
filter(netflix_data, MAIN_PRODUCTION == "US")
```


## select() variables

### Select variables using `select()` function

Printing observations is key to investigating data, but datasets often have hundreds, thousands of variables

`select()` function selects __columns__ of data (i.e., variables) you specify

- first argument is the name of data frame object
- remaining arguments are variable names, which are separated by commas and without quotes

Without __assignment__ (`<-`), `select()` by itself simply prints selected vars
```{r}
#?select
#duration keep it, to see who wants to watch longer stuff
#select but use minus to drop season and release year, to show it yields the same as just picking those to select
names(netflix_data)
select(netflix_data, TITLE, SCORE, NUMBER_OF_VOTES, DURATION, MAIN_GENRE, MAIN_PRODUCTION)
```

### Select variables using `select()` function

Recall that all `dplyr` functions (e.g., `select()`) return a new data frame object

- __type__ equals "list"
- __length__ equals number of vars you select

```{r}
typeof(select(netflix_data, TITLE, SCORE, NUMBER_OF_VOTES, MAIN_GENRE, MAIN_PRODUCTION))
length(select(netflix_data, TITLE, SCORE, NUMBER_OF_VOTES, MAIN_GENRE, MAIN_PRODUCTION))
```

`glimpse()`: tidyverse function for viewing data frames

- a cross between `str()` and simply printing data
```{r, eval=FALSE}
?glimpse
glimpse(netflix_data)
```

`glimpse()` a `select()` set of variables
```{r}
glimpse(select(netflix_data, TITLE, SCORE, NUMBER_OF_VOTES, MAIN_GENRE, MAIN_PRODUCTION))
```

### Select variables using `select()` function

With __assignment__ (`<-`), `select()` creates a new object containing only the variables you specify

```{r}
netflix_small <- select(netflix_data, TITLE, SCORE, NUMBER_OF_VOTES, MAIN_GENRE, MAIN_PRODUCTION)

glimpse(netflix_small)
```

### Select

`select()` can use "helper functions" `starts_with()`, `contains()`, and `ends_with()` to choose columns 

Example:
```{r}
names(netflix_data)
select(netflix_data, starts_with("MAIN"))
select(netflix_data, contains("OF"))
select(netflix_data, ends_with("RE"))
```

1. Use `select()` to familiarize yourself with variables in the data frame
1. Practice using the `contains()` and `ends_with()` helper functions to to choose variables

### Arrange() 
`arrange()` function can change the ordering of the rows (i.e., sort rows), it "arranges" rows in a data frame by sortsing the observations

\medskip
Syntax: `arrange(x,...)`

- First argument, `x`, is a data frame
- Subsequent arguments are a "comma separated list of unquoted variable names"

```{r, results="hide"}
netflix_data
arrange(netflix_data, SCORE)
```
Data frame goes back to previous order unless you __assign__ the new order
```{r, results="hide"}
netflix_data
netflix_data <- arrange(netflix_data, SCORE)
netflix_data
```

### Ascending and descending order

- `arrange()` sorts in __ascending__ order by default
- use `desc()` to sort a column by descending order

```{r results="hide"}
arrange(netflix_data, desc(SCORE))
```

Can sort by multiple variables
```{r results="hide"}
arrange(netflix_data, desc(SCORE), desc(RELEASE_YEAR), TITLE)

#sort by descending by IMDb score and descending by release year and by title; combine with select

select(arrange(netflix_data, desc(SCORE), desc(RELEASE_YEAR), TITLE),
       TITLE, RELEASE_YEAR, SCORE, NUMBER_OF_VOTES, NUMBER_OF_SEASONS, contentType)

```

### `arrange()`, missing values sorted at the end

Missing values automatically sorted at the end, regardless of whether you sort ascending or descending

Below, we sort by score, then by release year, then by title
```{r, results="hide"}
#by descending score, descending release year, title
select(arrange(netflix_data, desc(SCORE), desc(RELEASE_YEAR), TITLE),
       TITLE, RELEASE_YEAR, SCORE, NUMBER_OF_VOTES, NUMBER_OF_SEASONS, contentType)

#by score, release year, descending title
select(arrange(netflix_data, SCORE, RELEASE_YEAR, desc(TITLE)),
       TITLE, RELEASE_YEAR, SCORE, NUMBER_OF_VOTES, NUMBER_OF_SEASONS, contentType)
```
Can sort by `is.na` to put missing values first
```{r}
select(arrange(netflix_data, desc(is.na(contentType)), desc(SCORE), desc(RELEASE_YEAR), TITLE),
       TITLE, RELEASE_YEAR, SCORE, NUMBER_OF_VOTES, NUMBER_OF_SEASONS, contentType)
```

### Rename variables

`rename()` function renames variables within a data frame object

\medskip Syntax:

- `rename(obj_name, new_name = old_name,...)`
\medskip
```{r results="hide"}
rename(netflix_data, CONTENT_TYPE = contentType, DESCRIPTION = description, CONTENT_RATING = contentRating, GENRE = genre, FORMATTED_DURATION = formattedDuration, RELEASED_DATE = releasedDate, HOURS_VIEWED = 'Hours Viewed', ACTORS = actors, DIRECTOR = director, CREATOR = creator, AUDIO = audio, SUBTITLE = subtitle, SEASON_START_DATE = seasonStartDate)

names(netflix_data)
```
Variable names do not change permanently unless we combine rename with assignment
\medskip
```{r results="hide"}
rename_netflix_data <- rename(netflix_data, CONTENT_TYPE = contentType, DESCRIPTION = description, CONTENT_RATING = contentRating, GENRE = genre, FORMATTED_DURATION = formattedDuration, RELEASED_DATE = releasedDate, HOURS_VIEWED = 'Hours Viewed', ACTORS = actors, DIRECTOR = director, CREATOR = creator, AUDIO = audio, SUBTITLE = subtitle, SEASON_START_DATE = seasonStartDate)

names(rename_netflix_data)
rm(rename_netflix_data)
```

## filter() rows

### The `filter()` function

`filter()` allows you to __select observations__ based on values of variables

- Arguments
    - first argument is name of data frame
    - subsequent arguments are _logical expressions_ to filter the data frame
    - Multiple expressions separated by commas work as __AND__ operators (e.g., condtion 1 `TRUE` AND condition 2 `TRUE`)

- What is the result of a `filter()` command?
    - `filter()` returns a data frame consisting of rows where the condition is `TRUE`

```{r, eval=FALSE}
?filter
```

Example from data frame object `netflix_data`, each obs is a show or film

- Show all obs where the show only had one season [output omitted]
```{r results="hide"}
filter(netflix_data, NUMBER_OF_SEASONS == 1)
```

Note that resulting object is list, consisting of obs where condition `TRUE`
```{r}
nrow(netflix_data)
nrow(filter(netflix_data, NUMBER_OF_SEASONS == 1))
```

### The `filter()` function, base R equivalents

**Task**: Count the number of shows that only had one season.

\bigskip

**[tidyverse]** Using `filter()`:\smallskip
```{r}
nrow(filter(netflix_data, NUMBER_OF_SEASONS == 1))
```

\bigskip

**[base R]** Using `[]` and `$`:\smallskip
```{r}
nrow(netflix_data[netflix_data$NUMBER_OF_SEASONS == 1, ])
```

\bigskip

**[base R]** Using `subset()`:\smallskip
```{r}
nrow(subset(netflix_data, NUMBER_OF_SEASONS == 1))
```

### Filter, character variables

Use single quotes `''` or double quotes `""` to refer to values of character variables
```{r}
glimpse(select(netflix_data, RELEASE_YEAR, MAIN_GENRE))
```

Identify all shows that only had one season and was released in 2020

- Shows that only had one season
```{r results="hide"}
filter(netflix_data, NUMBER_OF_SEASONS == 1)
```

- Shows that were released in 2020
```{r results="hide"}
filter(netflix_data, NUMBER_OF_SEASONS == 1, RELEASE_YEAR == "2020")
```

- Shows that had one season and was released in 2020
```{r results="hide"}
filter(netflix_data, NUMBER_OF_SEASONS == 1, RELEASE_YEAR == "2020")
```

### Filter by multiple conditions, base R equivalents

**Task**: Count the number of shows that had one season, released in 2020, and was a drama.

\medskip

**[tidyverse]** Using `filter()`:\smallskip
```{r}
nrow(filter(netflix_data, NUMBER_OF_SEASONS == 1, RELEASE_YEAR == "2020",
       MAIN_GENRE == "drama"))
```

\medskip

**[base R]** Using `[]` and `$`:\smallskip
```{r}
nrow(netflix_data[netflix_data$NUMBER_OF_SEASONS == 1 &
                    netflix_data$RELEASE_YEAR == "2020" &
                    netflix_data$MAIN_GENRE == "drama", ])
```

\medskip

**[base R]** Using `subset()`:\smallskip
```{r}
nrow(subset(netflix_data, NUMBER_OF_SEASONS == 1 & RELEASE_YEAR == "2020" & 
              MAIN_GENRE == "drama"))
```

### Logical operators for comparisons

logical operators useful for: filter obs w/ `filter()`; create variables w/ `mutate()`

- logical operators also work when using Base R functions

Operator symbol | Operator meaning
-------|-------
`==` | Equal to
`!=` | Not equal to
`>` | greater than
`>=` | greater than or equal to
`<` | less than
`<=` | less than or equal to
`&` | AND 
`|` | OR
`%in%` | includes

- Visualization of "Boolean" operators (e.g., AND, OR, AND NOT)

!["Boolean" operations, x=left circle, y=right circle, from Wichkam (2018)]{width=40%}

### Aside: `count()` function

\medskip `count()` function from `dplyr` package counts the number of obs by group
```{r, eval=FALSE, echo=FALSE}
?count
```

__Syntax__ [see help file for full syntax]

- `count(x,...)`

__Arguments__ [see help file for full arguments]

- `x`: an object, often a data frame
- `...`: variables to group by

Examples of using `count()`

- Without vars in `...` argument, counts number of obs in object
```{r, results="hide"}
count(netflix_data)
  # netflix_data %>% count() # same as above but using pipes
str(count(netflix_data))
  # netflix_data %>% count() %>% str() # same as above but using pipes
```
- With vars in `...` argument, counts number of obs per variable value
    - This is the best way to create frequency table, better than `table()`
    - note: by default, `count()` always shows `NAs` [this is good!]
```{r, results="hide"}
count(netflix_data, MAIN_GENRE)
  # netflix_data %>% count(MAIN_GENRE) # same as above but using pipes
str(count(netflix_data, MAIN_GENRE))
  # netflix_data %>% count(MAIN_GENRE) %>% str() # same as above but using pipes
```

### Filters and comparisons, Demonstration

Shows that had one season and/or released in 2020 \bigskip

```{r results="hide"}
# one AND two seasons
filter(df_school,visits_by_100751 >= 1, visits_by_110635 >= 1) 
filter(df_school,visits_by_100751 >= 1 & visits_by_110635 >= 1) # same same

df_school[df_school$visits_by_100751 >= 1 &
            df_school$visits_by_110635 >= 1, ] # using [] and $

subset(df_school,visits_by_100751 >= 1 &
         visits_by_110635 >= 1) # using subset()

nrow(subset(netflix_data, NUMBER_OF_SEASONS == 1 & RELEASE_YEAR == "2020" & 
              MAIN_GENRE == "drama"))
```

\bigskip

```{r results="hide"}
# Berkeley OR Bama
filter(df_school,visits_by_100751 >= 1 | visits_by_110635 >= 1)

df_school[df_school$visits_by_100751 >= 1 |
            df_school$visits_by_110635 >= 1, ] # using [] and $

subset(df_school,visits_by_100751 >= 1 |
         visits_by_110635 >= 1) # using subset()
```

### Filters and comparisons, Demonstration (cont.)

Apply `count()` function on top of `filter()` function to count the number of observations that satisfy criteria

- Avoids printing individual observations\medskip

```{r}
# Number of schools that get visit by Berkeley AND Bama
count(filter(df_school, visits_by_100751 >= 1 & visits_by_110635 >= 1))

# Number of schools that get visit by Berkeley OR Bama
count(filter(df_school, visits_by_100751 >= 1 | visits_by_110635 >= 1))
```

- Note: You could also use any of the base R equivalents from the previous slide

### Filters and comparisons, `>=`

Number of public high schools that are at least 50% Black in Alabama compared to number of schools that received visit by Bama:\medskip 

```{r}
# at least 50% black
count(filter(df_school, school_type == "public", pct_black >= 50, 
             state_code == "AL"))

# at least 50% black and received visit by Bama
count(filter(df_school, school_type == "public", pct_black >= 50, 
             state_code == "AL", visits_by_100751 >= 1))
```

### Filters and comparisons, `>=` (cont.)

Number of public high schools that are at least 50% White in Alabama compared to number of schools that received visit by Bama:\medskip 

```{r}
# at least 50% white
count(filter(df_school, school_type == "public", pct_white >= 50, 
             state_code == "AL"))

# at least 50% white and received visit by Bama
count(filter(df_school, school_type == "public", pct_white >= 50, 
             state_code == "AL", visits_by_100751 >= 1))
```

### Filters and comparisons, not equals (`!=`)

Count the number of high schools visited by University of Colorado (126614) that are not located in CO
```{r}
#number of high schools visited by U Colorado
count(filter(df_school, visits_by_126614 >= 1))

#number of high schools visited by U Colorado not located in CO
count(filter(df_school, visits_by_126614 >= 1, state_code != "CO"))

#number of high schools visited by U Colorado located in CO
#count(filter(df_school, visits_by_126614 >= 1, state_code == "CO"))
```

### Filters and comparisons, `%in%` operator

What if you wanted to count the number of schools visited by Bama (100751) in a group of states?
```{r}
count(filter(df_school,visits_by_100751 >= 1, state_code == "MA" |
               state_code == "VT" | state_code == "ME"))
```
Easier way to do this is with `%in%` operator
```{r}
count(filter(df_school,visits_by_100751 >= 1, state_code %in% c("MA","ME","VT")))
```

Select the private high schools that got either 2 or 3 visits from Bama
```{r}
count(filter(df_school, visits_by_100751 %in% 2:3, school_type == "private"))
```
### Identifying data type and possible values helpful for filtering

- `typeof()` and `str()` shows internal data type of a variable 
- `table()` to show potential values of categorical variables

```{r}
typeof(df_event$event_type)
str(df_event$event_type)  # double quotes indicate character
table(df_event$event_type, useNA="always")

typeof(df_event$med_inc)
str(df_event$med_inc)
```

Now that we know `event_type` is a character, we can filter values
```{r}
count(filter(df_event, event_type == "public hs", event_state =="CA"))
#below code would return an error because variables are character
#count(filter(df_event, event_type == public hs, event_state ==CA))
```

### Filtering and missing values

Wickham (2018) states:

- "`filter()` only includes rows where condition is TRUE; it excludes both `FALSE` and `NA` values. To preserve missing values, ask for them explicitly:"

\medskip Investigate var `df_event$fr_lunch`, number of free/reduced lunch students

- only available for visits to public high schools

```{r}
#visits to public HS with less than 50 students on free/reduced lunch
count(filter(df_event,event_type == "public hs", fr_lunch<50))
#visits to public HS, where free/reduced lunch missing
count(filter(df_event,event_type == "public hs", is.na(fr_lunch)))
#visits to public HS, where free/reduced is less than 50 OR is missing
count(filter(df_event,event_type == "public hs", fr_lunch<50 | is.na(fr_lunch)))
```



## Introduce mutate() function 

### Introduce `mutate()` function

`mutate()` is __tidyverse__ approach to creating variables (not __Base R__ approach)

Description of `mutate()`

- creates new columns (variables) that are functions of existing columns
- After creating a new variable using `mutate()`, every row of data is retained
- `mutate()` works best with pipes `%>%`

__Task__: 

- Using data frame `school_v2` create new variable that measures the pct of students on free/reduced lunch (output omitted)
```{r, results='hide'}
# create new dataset with fewer vars; not necessary to do this
#school_sml <- school_v2 %>% select(ncessch, school_type, num_fr_lunch, total_students)

# create new var
#school_sml %>% 
  #mutate(pct_fr_lunch = num_fr_lunch/total_students) 

# remove data frame object
#rm(school_sml) 
```

### Investigate `mutate()` syntax


```{r, eval=FALSE, echo=FALSE}
?mutate
```

__Usage (i.e., syntax)__

- `mutate(.data,...)`

__Arguments__

- `.data`: a data frame
    - if using `mutate()` after pipe operator `%>%`, then this argument can be omitted
        - Why? Because data frame object to left of `%>%` "piped in" to first argument of `mutate()`
- `...`: expressions used to create new variables
    - "Name-value pairs of expressions"
    - "The name of each argument will be the name of a new variable, and the value will be its corresponding value." 
    - "Use a `NULL` value in mutate to drop a variable." 
    - "New variables overwrite existing variables of the same name"


__Value__

- returns a (data frame) object that contains the original input data frame and new variables that were created by `mutate()`

### Investigate `mutate()` syntax


```{r, eval=FALSE, echo=FALSE}
?mutate
```

__Can create variables using standard mathematical or logical operators__  [output omitted]

```{r, results="hide"}
#glimpse(school_v2)
#school_v2 %>% 
  #select(state_code,school_type,ncessch,med_inc,num_fr_lunch,total_students,num_took_math) %>%
  #mutate( # each argument creates a new variable, name of argument is name of variable
    #one = 1,
    #med_inc000 = med_inc/1000,
    #pct_fr_lunch = num_fr_lunch/total_students*100,
    #took_math_na = is.na(num_took_math)==1
  #) %>%
  #select(state_code,school_type,ncessch,one,med_inc,med_inc000,num_fr_lunch,total_students,pct_fr_lunch,num_took_math,took_math_na)
```


__Can create variables using "helper functions" called within `mutate()`__ [output omitted]

- These are standalone functions can be called *within* `mutate()`
    - e.g., `if_else()`, `recode()`, `case_when()`
- will walk through helper functions in more detail in subsequent sections of lecture

```{r, results="hide"}
#school_v2 %>% 
  #select(state_code,ncessch,name,school_type) %>%
  #mutate(public = if_else(school_type == "public", 1, 0))
```

### Introduce `mutate()` function

New variable not retained unless we __assign__ `<-` it to an object (existing or new)

\medskip 

- __`mutate()` without assignment__
```{r, results='hide'}
#school_v2 %>% mutate(pct_fr_lunch = num_fr_lunch/total_students)

#names(school_v2)
```

\medskip 

- __`mutate()` with assignment__
```{r, results="hide"}
#school_v2_temp <- school_v2 %>% 
  #mutate(pct_fr_lunch = num_fr_lunch/total_students)

#names(school_v2_temp)
#rm(school_v2_temp)

```

### `mutate()` can create multiple variables at once

`mutate()` can create multiple variables at once

```{r, results='hide'}
#school_v2 %>% 
  #mutate(pct_fr_lunch = num_fr_lunch/total_students,
         #pct_prof_math= num_prof_math/num_took_math) %>%
  #select(num_fr_lunch, total_students, pct_fr_lunch, 
         #num_prof_math, num_took_math, pct_prof_math)
```

Or we could write code this way:
```{r, results="hide"}
#school_v2 %>% 
  #select(num_fr_lunch, total_students, num_prof_math, num_took_math) %>%
  #mutate(pct_fr_lunch = num_fr_lunch/total_students,
         #pct_prof_math= num_prof_math/num_took_math) 
```

`mutate()` can use variables previously created within `mutate()`
```{r, results="hide"}
#school_v2 %>% 
  #select(num_prof_math, num_took_math, num_took_read,num_prof_read) %>%
  #mutate(pct_prof_math = num_prof_math/num_took_math,
         #pct_prof_read = num_prof_read/num_took_read,
         #avg_pct_prof_math_read = (pct_prof_math + pct_prof_read)/2) 
```
### `mutate()`, removing variables created by `mutate()`

Within `mutate()` use syntax `var_name = NULL` to remove variable from data frame

- note: Variable not permanently removed from data frame unless you use assignment `<-` to create new data frame or overwrite existing data frame
```{r, results='hide'}
#ncol(school_v2)
#school_v2 %>% 
  #select(num_prof_math, num_took_math, num_took_read,num_prof_read) %>% glimpse()

#school_v2 %>% 
  #select(num_prof_math, num_took_math, num_took_read,num_prof_read) %>% 
  #mutate(num_prof_math = NULL, num_took_math = NULL) %>% glimpse()
#But variables not permanently removed because we didn't use assignment
#ncol(school_v2)
```
Why would we remove variables within `mutate()` rather `select()`?

- remove temporary "work" variables used to create desired variable
- Example: measure of average of pct who passed math and pct who passed reading
```{r, results='hide'}
#school_v2 %>% 
  #select(num_prof_math, num_took_math, num_took_read,num_prof_read) %>%
  #mutate(pct_prof_math = num_prof_math/num_took_math, # create work var
         #pct_prof_read = num_prof_read/num_took_read, # create work var
         #avg_pct_prof_math_read = (pct_prof_math + pct_prof_read)/2, #create analysis var
         #pct_prof_math = NULL, # remove work var
         #pct_prof_read = NULL) %>% # remove work var
  #glimpse()
```

### Student exercise using mutate()

1. Using the object `school_v2`, select the following variables (`num_prof_math`, `num_took_math`, `num_prof_read`, `num_took_read`) and create a measure of percent proficient in math `pct_prof_math` and percent proficient in reading `pct_prof_read`.  

2. Now using the code for question 1, filter schools where at least 50% of students are proficient in math **&** reading.  

3. Count the number of schools from question 2.

4. Using `school_v2`, using `mutate()` combined with `is.na()` create a dichotomous indicator variable `med_inc_na` that identifies whether `med_inc` is missing (`NA`) or not. And then use syntax `count(var_name)` to create frequency table of variable `med_inc_na`. How many observations are missing? 


### Solutions for exercise using mutate()

1. Using the object `school_v2`, select the following variables (`num_prof_math`, `num_took_math`, `num_prof_read`, `num_took_read`) and create a measure of percent proficient in math `pct_prof_math` and percent proficient in reading `pct_prof_read`.

```{r}
#school_v2 %>%
  #select(num_prof_math, num_took_math, num_prof_read, num_took_read) %>%
  #mutate(pct_prof_math = num_prof_math/num_took_math,
         #pct_prof_read = num_prof_read/num_took_read) 
```
### Solutions for exercise using mutate()

2. Now using the code for question 1, filter schools where at least 50% of students are proficient in math **&** reading.
```{r}
#school_v2 %>%
  #select(num_prof_math, num_took_math, num_prof_read, num_took_read) %>%
  #mutate(pct_prof_math = num_prof_math/num_took_math,
         #pct_prof_read = num_prof_read/num_took_read) %>%
  #filter(pct_prof_math >= 0.5 & pct_prof_read >= 0.5) 
```

### Solutions for exercise using mutate()
3. Count the number of schools from question 2.
```{r}
#school_v2 %>%
  #select(num_prof_math, num_took_math, num_prof_read, num_took_read) %>%
  #mutate(pct_prof_math = num_prof_math/num_took_math,
         #pct_prof_read = num_prof_read/num_took_read) %>%
  #filter(pct_prof_math >= 0.5 & pct_prof_read >= 0.5) %>%
  #count()
```

### Solutions for exercise using mutate()
4. Using `school_v2`, using `mutate()` combined with `is.na()` create a dichotomous indicator variable `med_inc_na` that identifies whether `med_inc` is missing (`NA`) or not. And then use syntax `count(var_name)` to create frequency table of variable `med_inc_na`. How many observations are missing? 

```{r}
#school_v2 %>% 
  #mutate(med_inc_na = is.na(med_inc)) %>%
  #count(med_inc_na)
```

## Using if_else() function within mutate()

### Using `if_else()` function within `mutate()`

```{r, eval=FALSE, echo=FALSE}
?if_else
```

__Description__

- if `<condition>` `TRUE`, assign value; if `<condition>` `FALSE` assign value

__Usage (i.e., syntax)__

- `if_else(logical condition, true, false, missing = NULL)`

__Arguments__

- `logical condition`: a condition that evaluates to `TRUE` or `FALSE`
- `true`: value to assign if condition `TRUE`
- `false`: value to assign if condition `FALSE`
- `missing`: value to assign to rows that have value `NA` for condition
    - default is `missing = NULL`; means that if condition is `NA`, then new_var == `NA`
    - But can assign different values to `NA`s, e.g., `missing = -9`

__Value__

- "Where condition is TRUE, the matching value from true, where it's FALSE, the matching value from false, otherwise NA."
- Unless otherwise specified, `NA`s in "input" var(s) assigned `NA` in "output var"

__Example__: Create 0/1 indicator of whether got at least one visit from Berkeley
```{r, results="hide"}
#school_v2 %>% 
  #mutate(got_visit_berkeley = if_else(visits_by_berkeley>0,1,0)) %>%
  #count(got_visit_berkeley)
```

### `if_else()` within `mutate()` to create 0/1 indicator variables

We often create dichotomous (0/1) indicator variables of whether something happened (or whether something is TRUE)

- Variables that are of substantive interest to project
    - e.g., did student graduate from college
- Variables that help you investigate data, check quality
    - e.g., indicator of whether an observation is missing/non-missing for a particular variable

### Using `if_else()` within `mutate()`

__Task__

- Create 0/1 indicator if school has median income greater than $100,000

Usually a good idea to investigate "input" variables __before__ creating analysis vars
```{r, results="hide"}
#str(school_v2$med_inc) # investigate variable type
#school_v2 %>% count(med_inc) # frequency count, but this isn't very helpful

#school_v2 %>% filter(is.na(med_inc)) %>% count()
# shows number of obs w/ missing med_inc
```
Create variable
```{r}
#school_v2 %>% select(med_inc) %>% 
  #mutate(inc_gt_100k= if_else(med_inc>100000,1,0)) %>%
  #count(inc_gt_100k) # note how NA values of med_inc treated
```

### Using `if_else()` within `mutate()`

__Task__: 

- Create 0/1 indicator if school has median income greater than $100,000. 

This time, let's experiment with the `missing` argument of `if_else()`
```{r, eval=FALSE}
#what we wrote before
#school_v2 %>% select(med_inc) %>% 
  #mutate(inc_gt_100k= if_else(med_inc>100000,1,0)) %>%
  #count(inc_gt_100k)

#manually write out the default value for `missing`
#school_v2 %>% select(med_inc) %>% 
  #mutate(inc_gt_100k= if_else(med_inc>100000,1,0, missing = NULL)) %>%
  #count(inc_gt_100k) # note how NA values of med_inc treated

#school_v2 %>% select(med_inc) %>% 
  #mutate(inc_gt_100k= if_else(med_inc>100000,1,0, missing = NA_real_)) %>%
  #count(inc_gt_100k) # note how NA values of med_inc treated
# NA can be coerced to any other vector type except raw: 
# NA_integer_, NA_real_, NA_complex_ and NA_character_

# Here we give missing values in condition the value of -9 in new variable
#school_v2 %>% select(med_inc) %>% 
  #mutate(inc_gt_100k= if_else(med_inc>100000,1,0, missing = -9)) %>%
  #count(inc_gt_100k) 
```

### Using `if_else()` function within `mutate()`

__Task__

- Create 0/1 indicator variable `nonmiss_math` which indicates whether school has non-missing values for the variable `num_took_math`
    - note: `num_took_math` refers to number of students at school that took state math proficiency test


Usually a good to investigate "input" variables before creating analysis vars
```{r, results="hide"}
#school_v2 %>% count(num_took_math) # this isn't very helpful
#school_v2 %>% filter(is.na(num_took_math)) %>% count(num_took_math) # shows number of obs w/ missing med_inc
```
Create variable
```{r}
#school_v2 %>% select(num_took_math) %>% 
  #mutate(nonmiss_math= if_else(!is.na(num_took_math),1,0)) %>%
  #count(nonmiss_math) # note how NA values treated
```

### Student exercises `if_else()`

1. Using the object `school_v2`, create 0/1 indicator variable `in_state_berkeley` that equals `1` if the high school is in the same state as UC Berkeley (i.e., `state_code=="CA"`).  
2. Create 0/1 indicator `berkeley_and_irvine` of whether a school got at least one visit from UC Berkeley __AND__ from UC Irvine.  
3. Create 0/1 indicator `berkeley_or_irvine` of whether a school got at least one visit from UC Berkeley __OR__ from UC Irvine.

### Exercise`if_else()` solutions

1. Using the object `school_v2`, create 0/1 indicator variable `in_state_berkeley` that equals `1` if the high school is in the same state as UC Berkeley (i.e., `state_code=="CA"`). 
```{r, results="hide"}
#str(school_v2$state_code) # investigate input variable
#school_v2 %>% filter(is.na(state_code)) %>% count() # investigate input var

#Create var
#school_v2 %>% mutate(in_state_berkeley=if_else(state_code=="CA",1,0)) %>%
  #count(in_state_berkeley)
```

### Exercise`if_else()` solutions

2. Create 0/1 indicator `berkeley_and_irvine` of whether a school got at least one visit from UC Berkeley __AND__ from UC Irvine.
```{r, results="hide"}
#investigate input vars
#school_v2 %>% select(visits_by_berkeley, visits_by_irvine) %>% str() 
#school_v2 %>% filter(is.na(visits_by_berkeley)) %>% count()
#school_v2 %>% filter(is.na(visits_by_irvine)) %>% count()

#create variable
#school_v2 %>% 
  #mutate(berkeley_and_irvine=if_else(visits_by_berkeley>0 
   # & visits_by_irvine>0,1,0)) %>%
  #count(berkeley_and_irvine)
```

### Exercise`if_else()` solutions

3. Create 0/1 indicator `berkeley_or_irvine` of whether a school got at least one visit from UC Berkeley __OR__ from UC Irvine.
```{r, results="hide"}
#school_v2 %>% 
  #mutate(berkeley_or_irvine=if_else(visits_by_berkeley>0 | visits_by_irvine>0,1,0)) %>%
  #count(berkeley_or_irvine)
```

## Using recode() function within mutate()

### Using `recode()` function within `mutate()`

```{r, eval=FALSE, echo=FALSE}
?recode
```
__Description__: Recode values of a variable

__Usage (i.e., syntax)__

- recode(.x, ..., .default = NULL, .missing = NULL)

__Arguments__ [see help file for further details]

- `.x`	A vector (e.g., variable) to modify
- `...`	Specifications for recode, of form `current_value = new_recoded_value` 
- `.default`:	If supplied, all values not otherwise matched given this value. 
- `.missing`: If supplied, any missing values in .x replaced by this value.

__Example__: Using data frame `wwlist`, create new 0/1 indicator `public_school` from variable `school_type`
```{r, results="hide"}
#str(wwlist$school_type)
#wwlist %>% count(school_type)

#wwlist_temp <- wwlist %>% select(school_type) %>% 
 # mutate(public_school = recode(school_type,"public" = 1, "private" = 0))

#wwlist_temp %>% head(n=10)
#str(wwlist_temp$public_school) # note: numeric variable
#wwlist_temp %>% count(public_school) # note the NAs
#rm(wwlist_temp)
```
### Using `recode()` function within `mutate()`

Recoding `school_type` could have been accomplished using `if_else()`

- Use `recode()` when new variable has more than two categories

__Task__: Create `school_catv2` based on `school_category` with these categories:

- "regular"; "alternative"; "special"; "vocational"

Investigate input var
```{r, results="hide"}
#str(wwlist$school_category) # character variable
#wwlist %>% count(school_category) 
```



Recode
```{r, results="hide"}
#wwlist_temp <- wwlist %>% select(school_category) %>% 
 # mutate(school_catv2 = recode(school_category,
    #"Alternative Education School" = "alternative",
   # "Alternative/other" = "alternative",
   # "Regular elementary or secondary" = "regular",
   # "Regular School" = "regular",
   # "Special Education School" = "special",
   # "Special program emphasis" = "special",
   # "Vocational Education School" = "vocational")
 # )
#str(wwlist_temp$school_catv2) # character variable created
#wwlist_temp %>% count(school_catv2)
#rm(wwlist_temp)
```
### Using `recode()` within `mutate()`

__Task__: Create `school_catv2` based on `school_category` with these categories:

- "regular"; "alternative"; "special"; "vocational"
- This time use the `.missing` argument to recode `NAs` to "unknown"

```{r, results="hide"}
#wwlist_temp <- wwlist %>% select(school_category) %>% 
 # mutate(school_catv2 = recode(school_category,
   # "Alternative Education School" = "alternative",
   # "Alternative/other" = "alternative",
   # "Regular elementary or secondary" = "regular",
   # "Regular School" = "regular",
   # "Special Education School" = "special",
   # "Special program emphasis" = "special",
   # "Vocational Education School" = "vocational",
   # .missing = "unknown")
 # )
#str(wwlist_temp$school_catv2)
#wwlist_temp %>% count(school_catv2)
#wwlist %>% count(school_category)
#rm(wwlist_temp)
```

### Using `recode()` within `mutate()` 

__Task__: Create `school_catv2` based on `school_category` with these categories:

- "regular"; "alternative"; "special"; "vocational"
- This time use the `.default` argument to assign the value "regular"

```{r, results="hide"}
#wwlist_temp <- wwlist %>% select(school_category) %>% 
  #mutate(school_catv2 = recode(school_category,
   # "Alternative Education School" = "alternative",
   # "Alternative/other" = "alternative",
   # "Special Education School" = "special",
   # "Special program emphasis" = "special",
  #  "Vocational Education School" = "vocational",
   # .default = "regular")
 # )
#str(wwlist_temp$school_catv2)
#wwlist_temp %>% count(school_catv2)
#wwlist %>% count(school_category)
#rm(wwlist_temp)
```
### Using `recode()` within `mutate()` 

__Task__: Create `school_catv2` based on `school_category` with these categories:

- This time create a numeric variable rather than character:
    - `1` for "regular"; `2` for "alternative"; `3` for "special"; `4` for "vocational"

```{r, results="hide"}
#wwlist_temp <- wwlist %>% select(school_category) %>% 
 # mutate(school_catv2 = recode(school_category,
  #  "Alternative Education School" = 2,
  #  "Alternative/other" = 2,
   # "Regular elementary or secondary" = 1,
  #  "Regular School" = 1,
  #  "Special Education School" = 3,
  #  "Special program emphasis" = 3,
   # "Vocational Education School" = 4)
 # )
#str(wwlist_temp$school_catv2) # note: numeric variable now
#wwlist_temp %>% count(school_catv2)
#wwlist %>% count(school_category)
#rm(wwlist_temp)
```
### Student exercise using `recode()` within `mutate()`

```{r, results="hide"}
#load(url("https://github.com/ozanj/rclass/raw/master/data/recruiting/recruit_event_somevars.RData"))

#names(df_event)
```

1. Using object `df_event`, assign new object `df_event_temp` and a numeric variable create `event_typev2` based on `event_type` with these categories: 
    - `1` for "2yr college"; `2` for "4yr college"; `3` for "other"; `4` for "private hs"; `5` for "public hs" 

2. This time use the `.default` argument to assign the value `5` for "public hs"

### Exercise using `recode()` within `mutate()` solutions 
Check input variable
```{r, results="hide"}
#names(df_event)
#str(df_event$event_type)
#df_event %>% count(event_type)
```

### Exercise using `recode()` within `mutate()` solutions 
1. Using object `df_event`, assign new object `df_event_temp` and create a numeric variable `event_typev2` based on `event_type` with these categories: 
    - `1` for "2yr college"; `2` for "4yr college"; `3` for "other"; `4` for "private hs"; `5` for "public hs"   

```{r results="hide"}
#df_event_temp <- df_event %>% 
 # select(event_type) %>%
#  mutate(event_typev2 = recode(event_type,
                           #   "2yr college" = 1,
                            #  "4yr college" = 2,
                            #  "other" = 3,
                            #  "private hs" = 4,
                            #  "public hs" = 5)
       #  )
#str(df_event_temp$event_typev2)
#df_event_temp %>% count(event_typev2)
#df_event %>% count(event_type)
```

### Exercise using `recode()` within `mutate()` solutions  

2. This time assign the value use the `.default` argument to assign the value `5` for "public hs"
```{r, results="hide"}
#df_event_temp <- df_event %>% select(event_type) %>% 
#  mutate(event_typev2 = recode(event_type,
  #  "2yr college" = 1,
  #  "4yr college" = 2,
  #  "other" = 3,
  #  "private hs" = 4,
   # .default = 5)
 # )
#str(df_event_temp$event_typev2)
#df_event_temp %>% count(event_typev2)
#df_event %>% count(event_type)
```

## Using case_when() function within mutate()

### Using `case_when()` function within `mutate()` 

```{r, eval=FALSE, echo=FALSE}
?case_when
```
`case_when()` useful for creating variable that is a function of multiple "input" variables

__Usage (i.e., syntax)__: `case_when(...)`

__Arguments__ [from help file; see help file for more details]

- `...`: A sequence of two-sided formulas. 
    - The left hand side (LHS) determines which values match this case. 
        - LHS must evaluate to a logical vector.     
    - The right hand side (RHS) provides the replacement value.
 
 
__Example task__: Using data frame `wwlist` and input vars `state` and `firstgen`, create a 4-category var with following categories:

- "instate_firstgen"; "instate_nonfirstgen"; "outstate_firstgen"; "outstate_nonfirstgen"

```{r, results="hide"}
#wwlist_temp <- wwlist %>% select(state,firstgen) %>%
#  mutate(state_gen = case_when(
  #  state == "WA" & firstgen =="Y" ~ "instate_firstgen",
  #  state == "WA" & firstgen =="N" ~ "instate_nonfirstgen",
 #   state != "WA" & firstgen =="Y" ~ "outstate_firstgen",
  #  state != "WA" & firstgen =="N" ~ "outstate_nonfirstgen")
#  )
#str(wwlist_temp$state_gen)
#wwlist_temp %>% count(state_gen)
```


### Using `case_when()` function within `mutate()` 

__Task__: Using data frame `wwlist` and input vars `state` and `firstgen`, create a 4-category var

Let's take a closer look at how values of inputs are coded into values of outputs
```{r, results="hide"}
#wwlist %>% select(state,firstgen) %>% str()
#count(wwlist,state)
#count(wwlist,firstgen)
```

Create variable
```{r, results="hide"}
#wwlist_temp <- wwlist %>% select(state,firstgen) %>%
#  mutate(state_gen = case_when(
 #   state == "WA" & firstgen =="Y" ~ "instate_firstgen",
 #   state == "WA" & firstgen =="N" ~ "instate_nonfirstgen",
 #   state != "WA" & firstgen =="Y" ~ "outstate_firstgen",
  #  state != "WA" & firstgen =="N" ~ "outstate_nonfirstgen")
#  )
```

Compare values of input vars to value of output var
```{r, results="hide"}
#wwlist_temp %>% count(state_gen)
#wwlist_temp %>% filter(is.na(state)) %>% count(state_gen)
#wwlist_temp %>% filter(is.na(firstgen)) %>% count(state_gen)
#wwlist_temp %>% filter(is.na(firstgen) | is.na(state)) %>% count(state_gen)
```

__Take-away__: by default var created by `case_when()` equals `NA` for obs where one of the inputs equals `NA`

### Student exercise using `case_when()` within `mutate()`

1. Using the object `school_v2` and input vars `school_type`, and `state_code` , create a 4-category var `state_type` with following categories:  
    - "instate_public"; "instate_private"; "outstate_public"; "outstate_private" 
    - Note: We are referring to CA as in-state for this example


### Exercise using `case_when()` within `mutate()` solution
Investigate
```{r, results="hide"}
#school_v2 %>% select(state_code,school_type) %>% str()
#count(school_v2,state_code)
#school_v2 %>% filter(is.na(state_code)) %>% count()

#count(school_v2,school_type)
#school_v2 %>% filter(is.na(school_type)) %>% count()
```

### Exercise using `case_when()` within `mutate()` solution
1. Using the object `school_v2` and input vars `school_type`, and `state_code` , create a 4-category var `state_type` with following categories:  
    - "instate_public"; "instate_private"; "outstate_public"; "outstate_private" 
```{r}
#school_v2_temp <- school_v2 %>% select(state_code,school_type) %>%
 # mutate(state_type = case_when(
  #  state_code == "CA" & school_type == "public"  ~ "instate_public",
 #   state_code == "CA" & school_type == "private" ~ "instate_private",
 #   state_code != "CA" & school_type == "public" ~ "outstate_public",
 #   state_code != "CA" & school_type == "private" ~ "outstate_private")
 # )

#school_v2_temp %>% count(state_type)
#school_v2_temp %>% filter(is.na(state_code)) %>% count(state_type) #no missing
#school_v2_temp %>% filter(is.na(school_type)) %>% count(state_type) #no missing
```




######################
